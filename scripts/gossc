#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
import io
import sys
import subprocess

import argparse
import jinja2

_find_unsafe = re.compile(r'[^\w@%+=:,./-]').search


def _parse_cli_arguments():
    parser = argparse.ArgumentParser(prog='gossc',
                                     description='high-level screen manager')
    subparsers = parser.add_subparsers(title='action', dest='action')

    # create the parser for the "init" command
    parser_init = subparsers.add_parser('init',
                                        help='init screen')
    parser_init.add_argument('screen_name',
                             help='screen name')
    parser_init.add_argument('--lines',
                             dest='lines',
                             type=int,
                             default=10000,
                             help='output buffer lines')

    # create the parser for the "exec" command
    parser_exec = subparsers.add_parser('exec',
                                        help='execute commands in screen')
    parser_exec.add_argument('screen_name',
                             help='screen name')
    parser_exec.add_argument('script_name',
                             nargs='?',
                             help='script name')

    # create the parser for the "plist" command
    parser_plist = subparsers.add_parser('plist',
                                         help='list all processes in screen')
    parser_plist.add_argument('screen_name',
                              help='screen name')
    parser_plist.add_argument('--no-headers',
                              dest='headers',
                              action='store_false',
                              default=True,
                              help='no header line')

    # create the parser for the "plist" command
    parser_pkill = subparsers.add_parser('pkill',
                                         help='kill all processes in screen')
    parser_pkill.add_argument('screen_name',
                              help='screen name')
    parser_pkill.add_argument('--force',
                              dest='force',
                              action='store_true',
                              default=False,
                              help='force kill')

    return parser.parse_args(sys.argv[1:])


def quote(s):
    """Return a shell-escaped version of the string *s*."""
    if not s:
        return "''"
    if _find_unsafe(s) is None:
        return s

    # use single quotes, and put single quotes into double quotes
    # the string $'b is then quoted as '$'"'"'b'
    return "'" + s.replace("'", "'\"'\"'") + "'"


_template_cache = {}
_template_globals = dict(
    quote=quote,
)


def get_render(script):
    template = _template_cache.get(script, None)
    if template is None:
        env = jinja2.Environment()
        template = env.from_string(
            script.replace("\r\n", "\n"),
            globals=_template_globals)
        _template_cache[script] = template
    return template.render


def _find_screens(screen_name):
    command = get_render(
        "screen -ls {{quote(screen_name)}}")(screen_name=screen_name)
    process = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)
    output, unused_err = process.communicate()
    unused_retcode = process.poll()  # `screen -ls` always return 1

    screens = []
    screen_suffix = "." + screen_name
    for raw_line in io.BytesIO(output):
        if not raw_line.startswith("\t"):
            continue
        screen_sockname = raw_line.strip().partition("\t")[0]
        if screen_sockname.endswith(screen_suffix):
            screen_pid = int(screen_sockname.partition(".")[0])
            screens.append(screen_pid)
    return screens


def init_screen(namespace):
    screen_name = namespace.screen_name
    screens = _find_screens(screen_name)

    if not screens:
        command = get_render("""
echo "create screen [{{quote(screen_name)}}]"
screen -h {{history_lines}} -dmS {{quote(screen_name)}}
""")(screen_name=screen_name, history_lines=namespace.lines)
    else:
        command = get_render("""
echo "logout screen [{{screen_pid}}]"
screen -h {{history_lines}} -D -r {{screen_pid}} -p 0 -X stuff '\n'
""")(screen_pid=screens[0], history_lines=namespace.lines)
    subprocess.call(command, shell=True)


def exec_jobs(namespace):
    screen_name = namespace.screen_name
    screens = _find_screens(screen_name)
    if not screens:
        print >> sys.stderr, "screen not exists [%s]" % screen_name
        return

    commands = []
    for raw_line in sys.stdin:
        line = raw_line.rstrip('\r\n')
        commands.append(line)
    if not commands:
        return

    command = get_render("""
screen -d {{screen_pid}}
screen -D -r {{screen_pid}} -p 0 -X stuff '\n'
{% for command in commands -%}
screen -D -r {{screen_pid}} -p 0 -X stuff {{quote(command)}}
screen -D -r {{screen_pid}} -p 0 -X stuff '\n'
{% endfor -%}
""")(screen_pid=screens[0], commands=commands)
    subprocess.call(command, shell=True)


def plist_jobs(namespace):
    screen_name = namespace.screen_name
    screens = _find_screens(screen_name)
    if not screens:
        print >> sys.stderr, "screen not exists [%s]" % screen_name
        return

    if namespace.headers:
        script = "pgrep -P {{screen_pid}} | xargs -I{} ps u --ppid {}"
    else:
        script = "pgrep -P {{screen_pid}} | xargs -I{} ps u --no-headers --ppid {}"
    command = get_render(script)(screen_pid=screens[0])
    subprocess.call(command, shell=True)


def pkill_jobs(namespace):
    screen_name = namespace.screen_name
    screens = _find_screens(screen_name)
    if not screens:
        print >> sys.stderr, "screen not exists [%s]" % screen_name
        return

    command = get_render("""
echo "kill all jobs in screen [{{screen_pid}}]"
{% if force -%}
pgrep -P {{screen_pid}} | xargs -I{} pgrep -P {} | xargs -I{} kill -KILL {}
{% else -%}
pgrep -P {{screen_pid}} | xargs -I{} pgrep -P {} | xargs -I{} kill -INT {}
{% endif -%}
""")(screen_pid=screens[0], force=namespace.force)
    subprocess.call(command, shell=True)


def main():
    namespace = _parse_cli_arguments()
    {
        'init': init_screen,
        'exec': exec_jobs,
        'plist': plist_jobs,
        'pkill': pkill_jobs,
    }[namespace.action](namespace)


if __name__ == '__main__':
    main()
